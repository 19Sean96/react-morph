(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{"./src/pages/api/useMorphKeys.mdx":function(e,n,o){"use strict";o.r(n),o.d(n,"default",function(){return a});var s=o("./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js"),t=(o("./node_modules/react/index.js"),o("./node_modules/@mdx-js/react/dist/index.es.js")),p={},r="wrapper";function a(e){var n=e.components,o=Object(s.a)(e,["components"]);return Object(t.b)(r,Object.assign({},p,o,{components:n,mdxType:"MDXLayout"}),Object(t.b)("h1",{id:"usemorphkeys"},Object(t.b)("inlineCode",{parentName:"h1"},"useMorphKeys")),Object(t.b)("pre",null,Object(t.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"import { useMorphKeys } from 'react-morph';\n")),Object(t.b)("h3",{id:"usemorphkeysstring-options-morphoptions"},Object(t.b)("inlineCode",{parentName:"h3"},"useMorphKeys(string[], options: MorphOptions)")),Object(t.b)("p",null,"Return an ",Object(t.b)("strong",{parentName:"p"},"object")," with multiple morphs with the given keys.\nAlso, each morph will receive an incremental ",Object(t.b)("inlineCode",{parentName:"p"},"zIndex")," option prop."),Object(t.b)("pre",null,Object(t.b)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"const Index = () => {\n  const morphs = useMorphKeys(['key1', 'key2']);\n  // morphs = { key1: \u2026, key2: \u2026 }\n\n  return (\n    <main>\n      {toggle && <Item morphs={morphs} />}\n      {!toggle && <Details morphs={morphs} />}\n    </main>\n  );\n};\n\nconst Item = ({ morphs }) => (\n  <div {...morphs.key1}>\n    <p {...morphs.key2}>Foo</p>\n  </div>\n);\n\nconst Details = ({ morphs }) => (\n  <div {...morphs.key1}>\n    <h1 {...morphs.key2}>Foo</h1>\n  </div>\n);\n")))}a&&a===Object(a)&&Object.defineProperty(a,"__filemeta",{enumerable:!0,configurable:!0,value:{name:"MDXContent",filename:"src/pages/api/useMorphKeys.mdx"}}),a.isMDXComponent=!0}}]);
//# sourceMappingURL=src-pages-api-use-morph-keys.c138f4875e99a255afde.js.map